---
title:  "[DB] SQL 학습하기 - part1"
excerpt: "SQL 학습하기 - part1"

categories: Java
tags:
  - [DB]

toc: true
toc_sticky: true
 
date: 2022-02-24
last_modified_at: 2022-02-24
author_profile: false  
---

## not equal

 - ^= 와 != 가 <> 로 변환된다고 하니, <> 로 하는게 가장 바람직할듯
 - 하지만 성능에는 차이가 없다고 함

```sql
select * from emp where sal ^= 3000;
select * from emp where sal != 3000;
select * from emp where sal <> 3000;
```

## union

 - union 은 중복되는건 제거, union all 은 중복까지 모두 포함
 - 조회되는 모든 컬럼 값들로 중복을 판단한다. 
 - union 보다는 union all  성능이 좋다. 
 - 가능하면 union all 을 사용하고, 조회되는 컬럼을 최소화 하자.

## minus & intersect

 - minus 는 2개의 쿼리 수행 결과에 대해 차집합 결과이다. 
 - 아래 쿼리는 emp 조회 후 , deptno = 10 인 결과를 제외한 것이다. 
 - 보통 부정연산자가 들어가는 경우, 인덱스를 타지 않는데, 
 그 때 minus 연산을 활용하면 성능에 도움이 될 수 있다. 

```sql
SELECT EMPNO, ENAME, SAL, DEPTNO
  FROM EMP
where DEPTNO <> 10;

SELECT EMPNO, ENAME, SAL, DEPTNO
  FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO
  FROM EMP
 WHERE DEPTNO = 10;
```

 - intersect 는 minus 와는 다르게 교집합을 뽑아낸다.

 ```sql
  SELECT EMPNO, ENAME, SAL, DEPTNO
  FROM EMP
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO
  FROM EMP
 WHERE DEPTNO = 10
 ```

## exists & not exists 

 - exists 와 not exists 는 일종의 차집합 같은 것이다. 
 - 아래 쿼리에서는 HISTORY에 이력이 1건이상이라도 존재하는 MEMBER 를 조회한 것이다. 
 여러건이 존재한다면 최초 1건 발견시 다음 검색으로 진행한다. 
 - 이력이 1건도 존재하지 않는 MEMBER 를 찾기 위해서는 not exists 를 사용한다. 
 - 존재유무를 확인하는 것이므로, select 1 from 을 사용해도 된다. 
 
```sql
select *
  from MEMBER A
 where exists (select 1
          from HISTORY B
         where A.id = B.id
           and B.request_date like '202203%' ) 
 and kind = '010'
```

## having

 - group by 된 결과에서 추가로 조회 조건을 주어야 할때 사용

```sql
SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB
```

## 주요 함수

```sql
-- 아래 쿼리에서 length는 2 , lengthb 는 4가 나온다. 
SELECT LENGTH('한글'), LENGTHB('한글')
  FROM DUAL

SELECT ENAME, LENGTH(ENAME)
  FROM EMP
 WHERE LENGTH(ENAME) >= 5  

SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, 5)
  FROM EMP

--rpad
SELECT EMPNO,
       RPAD(SUBSTR(EMPNO, 1, 2), 4, '*') AS MASKING_EMPNO,
       ENAME,
       RPAD(SUBSTR(ENAME, 1, 1), LENGTH(ENAME), '*') AS MASKING_ENAME
 FROM  EMP
 WHERE LENGTH(ENAME) >= 5
   AND LENGTH(ENAME) < 8

--trunc 버림(절사) , round 올림(반올림)
SELECT EMPNO, ENAME, SAL,
       TRUNC(SAL / 21.5, 2) AS DAY_PAY,
       ROUND(SAL / 21.5 / 8, 1) AS TIME_PAY
  FROM EMP     

--next_day 돌아오는 요일 날짜 계산하기
select ADD_MONTHS(sysdate, 3)
        , NEXT_DAY(ADD_MONTHS(sysdate, 3), '월요일')
        , TO_CHAR(NEXT_DAY(ADD_MONTHS(sysdate, 3), '월요일'), 'YYYY-MM-DD')
from dual;  

--replace
SELECT '010-1234-5678' AS REPLACE_BEFORE,
       REPLACE('010-1234-5678', '-', ' ') AS REPLACE_1,
       REPLACE('010-1234-5678', '-') AS REPLACE_2
  FROM DUAL;
``` 

 - 

# Reference